{"version":3,"sources":["../../../../assets/Script/assets/Script/Navigator.js"],"names":["logger","require","getLogger","Navigator","debug","_allState","Map","_scenesStack","_sceneLaunchHandle","cc","director","on","Director","EVENT_AFTER_SCENE_LAUNCH","eventCustom","sceneName","detail","name","handleForward","bind","parameter","onSceneLaunched","argsLength","arguments","length","undefined","level","sceneStackLevel","goBackToSceneStackLevel","readyToLeaveSceneJS","getCurrentSceneJS","sceneKey","sceneState","get","state","saveState","loadScene","pop","handleBack","enterSceneJS","loadState","push","nextSceneKey","nextSceneIndex","delete","set","currentScene","getScene","currentCanvas","getChildByName","currentCustomJS","getComponent","locScenesStack","c","current","i","exist","module","exports"],"mappings":"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","file":"Navigator.js","sourceRoot":"../../../../assets/Script","sourcesContent":["'use strict';\n\nconst logger = require('Logger').getLogger('Navigator.js');\n\n/**\n * Navigator介绍:\n * ------------------------\n * 提供一个支持导航栈的Navigator类，支持以下特性\n * 0，记录场景切换的导航栈。\n * 1，场景之间可以传递参数，比如场景A要传个字符串给场景B。\n * 2，多个场景进入同一场景后，从场景返回前一个场景，不需要再判断前一个场景是谁，可以直接goBack返回。\n * 3，支持场景返回后页面数据恢复，比如场景A界面，输入框输入了一段文字，然后进入场景B，\n *    从场景B返回后可以恢复输入框文字(需要在场景A脚本实现固定接口支持)。\n * 4，兼容cc.director.loadScene调用，当场景切换不需要参数和保存状态时，可以直接使用cc.director.loadScene\n *    Navigator会监听并将场景加入导航栈中。（不过不推荐直接使用cc.director.loadScene，没有以上特性）\n *\n * Navigator使用方法:\n * ------------------------\n * a)在场景A向前加载新场景B[带参数][带回调]\n *   /// 默认\n *   navigator.navigate('B');\n *\n *   /// [带参数]\n *   let parameter = {};\n *   parameter.title = 'i am wang ronghui';\n *   navigator.navigate('B', parameter);\n *\n *   /// [带回调]\n *   navigator.navigate('B', function(scene){\n *      /// 切换成功处理\n *   });\n *\n *   /// [带参数] + [带回调]\n *   let parameter = {};\n *   parameter.title = 'i am wang ronghui';\n *   navigator.navigate('B', parameter, function(scene){\n *      /// 切换成功处理\n *   });\n *\n *   ~如果有传递parameter需在相应B.js内部实现loadState(parameter, state)函数接收参数parameter。\n *   ~如果要存储当前UI状态则实现saveState(state){ //将UI状态存储在参数state中,后续在loadState里恢复state }。\n *\n * c)场景B向后返回前一个场景A\n *   /// 默认\n *   navigator.goBack();\n *\n *   /// [带参数]\n *   let parameter = {};\n *   parameter.title = 'i am wang ronghui';\n *   navigator.goBack(parameter);\n *\n * d)场景B向后返回指定名字场景A\n *   /// 默认\n *   navigator.goBackToScene('A');\n *\n *   /// [带参数]\n *   let parameter = {};\n *   parameter.title = 'i am wang ronghui';\n *   navigator.goBackToScene('A', parameter);\n *\n * e)场景B向后返回根场景\n *   /// 默认\n *   navigator.goBackToRootScene();\n *\n *   /// [带参数]\n *   let parameter = {};\n *   parameter.title = 'i am wang ronghui';\n *   navigator.goBackToRootScene(parameter);\n *\n * 注意事项:\n * ------------------------\n * 挂载到场景的Canvas的自定义脚本的名字，必须要和场景文件的名字一致，否则无法调用到loadState或者saveState\n *\n */\nclass Navigator\n{\n    /**\n     * 构造方法\n     */\n    constructor(){\n        logger.debug('constructor');\n\n        this._allState = new Map();\n        this._scenesStack = [];\n        this._sceneLaunchHandle = false;\n\n        /*\n        *  支持外部使用cc.director.loadScene直接导航，记录下导航栈\n        */\n        cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, function (eventCustom) {\n            /// 内部处理了这里就忽略，这里仅为支持监听外部导航。\n            if(this._sceneLaunchHandle) {\n                this._sceneLaunchHandle = false;\n                return;\n            }\n\n            /// 获取当前场景\n            let sceneName = eventCustom.detail.name;\n            logger.debug('EVENT_AFTER_SCENE_LAUNCH sceneName = ' + sceneName);\n\n            this.handleForward(sceneName, null);\n        }.bind(this));\n    }\n\n    /**\n     * 向前加载sceneName场景\n     * @param {string} sceneName -场景名字\n     * @param {object} [parameter] -参数对象\n     * @param {function()} [onSceneLaunched] -新场景运行成功后回调\n     */\n    navigate(sceneName, parameter, onSceneLaunched){\n        logger.debug('navigate sceneName = ' + sceneName);\n        logger.debug('navigate parameter = ' + parameter);\n        logger.debug('navigate onSceneLaunched = ' + onSceneLaunched);\n\n        /// 可能parameter和onSceneLaunched只传了某一个\n        let argsLength = arguments.length;\n        if(argsLength === 2) {\n            if (typeof parameter === 'function') {\n                onSceneLaunched = parameter;\n                parameter = undefined;\n            }\n        }\n\n        /// 先检查下导航栈有没有该场景，如果有，则回退到相应场景，防止出现场景循环\n        let level = this.sceneStackLevel(sceneName);\n        if(level !== -1){\n            this.goBackToSceneStackLevel(level, parameter);\n            return;\n        }\n\n        let readyToLeaveSceneJS = this.getCurrentSceneJS();\n        if(readyToLeaveSceneJS){\n            let sceneKey = 'Scene-' + this._scenesStack.length;\n            let sceneState = this._allState.get(sceneKey);\n            let state = {};\n            sceneState.state = state;\n\n            if(typeof readyToLeaveSceneJS.saveState === 'function'){\n                readyToLeaveSceneJS.saveState(state);\n            }\n        }\n\n        cc.director.loadScene(sceneName, function () {\n            /// 加载新场景成功处理\n            logger.debug('navigate loadScene complete sceneName = ' + sceneName);\n\n            this._sceneLaunchHandle = true;\n            this.handleForward(sceneName, parameter);\n\n            /// 回调通知场景切换成功\n            if(onSceneLaunched){\n                onSceneLaunched();\n            }\n        }.bind(this));\n\n        logger.debug('navigate end');\n    }\n\n    /**\n     * 向后返回前一个场景\n     * @param {object} [parameter] -参数对象\n     */\n    goBack(parameter){\n        logger.debug('goBack');\n\n        /// 当前Scene出导航栈\n        this._scenesStack.pop();\n\n        /// 加载栈顶Scene\n        let sceneName = this._scenesStack[this._scenesStack.length - 1];\n        cc.director.loadScene(sceneName, function () {\n            logger.debug('goBack loadScene complete sceneName = ' + sceneName);\n\n            this._sceneLaunchHandle = true;\n            this.handleBack(parameter);\n        }.bind(this));\n    }\n\n    /**\n     * 向后返回前根场景\n     * @param {object} [parameter] -参数对象\n     */\n    goBackToRootScene(parameter){\n        logger.debug('goBackToRootScene');\n\n        this.goBackToSceneStackLevel(1, parameter);\n    }\n\n    /**\n     * 向后返回指定场景\n     * @param {string} sceneName -场景名字\n     * @param {object} [parameter] -参数对象\n     */\n    goBackToScene(sceneName, parameter){\n        logger.debug('goBackToScene sceneName = ' + sceneName);\n\n        let level = this.sceneStackLevel(sceneName);\n\n        if(level !== -1){\n            this.goBackToSceneStackLevel(level, parameter);\n        }\n    }\n\n\n    /*-------------------------私有方法begin-------------------------*/\n\n    /**\n     * 前进页面处理，加入导航栈，分配state\n     * @param {string} sceneName -场景名字\n     * @param {object} [parameter] -参数对象\n     */\n    handleForward(sceneName, parameter){\n        logger.debug('handleForward sceneName = ' + sceneName);\n        logger.debug('handleForward parameter = ' + parameter);\n\n        /// 加载新场景成功处理\n        let enterSceneJS = this.getCurrentSceneJS();\n        if(enterSceneJS){\n            /// 向前导航时只有parameter，没有页面状态，所以页面状态为null\n            if(typeof enterSceneJS.loadState === 'function'){\n                enterSceneJS.loadState(parameter, null);\n            }\n\n            /// 0，入导航栈\n            this._scenesStack.push(sceneName);\n\n            /// 1，由于后退时不清理状态，在这里将当前页面以及向前所有的状态清除\n            let nextSceneKey =  'Scene-' + this._scenesStack.length;\n            let nextSceneIndex = this._scenesStack.length;\n            while (this._allState.delete(nextSceneKey))\n            {\n                nextSceneIndex ++;\n                nextSceneKey = 'Scene-' + nextSceneIndex;\n            }\n\n            /// 2，设置个state给当前Scene\n            let sceneState = {};\n            let sceneKey = 'Scene-' + this._scenesStack.length;\n            logger.debug('handleForward sceneKey = ' + sceneKey);\n            this._allState.set(sceneKey, sceneState);\n\n            /// 3，记录下参数\n            parameter = parameter || {};\n            sceneState.parameter = parameter;\n            sceneState.state = {};\n        }\n    }\n\n    /**\n     * 后退页面处理，恢复场景\n     * @param {object} [parameter] -参数对象\n     */\n    handleBack(parameter){\n        logger.debug('handleBack');\n\n        /// 加载新场景成功处理\n        let enterSceneJS = this.getCurrentSceneJS();\n        if(enterSceneJS){\n            let sceneKey = 'Scene-' + this._scenesStack.length;\n            logger.debug('goBack loadScene complete sceneKey = ' + sceneKey);\n            let sceneState = this._allState.get(sceneKey);\n\n            /// 获取参数和页面状态，传入场景js,用于场景页面恢复\n            if(typeof enterSceneJS.loadState === 'function'){\n                /// 如果Back有带参数，优先使用参数，否则使用保留参数。\n                parameter = parameter || sceneState.parameter;\n                enterSceneJS.loadState(parameter, sceneState.state);\n            }\n        }\n    }\n\n    /**\n     * 获取当前场景脚本类\n     */\n    getCurrentSceneJS(){\n        let currentScene = cc.director.getScene();\n        if(currentScene){\n            let currentCanvas = currentScene.getChildByName('Canvas');\n            if(currentCanvas){\n                let currentCustomJS = currentCanvas.getComponent(currentScene.name);\n                if(currentCustomJS){\n                    return currentCustomJS;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * 返回到固定Level的场景\n     * @param {number} level -层级，比如1代表第一层\n     * @param {object} [parameter] -参数对象\n     */\n    goBackToSceneStackLevel(level, parameter){\n        logger.debug('goBackToSceneStackLevel');\n\n        let locScenesStack = this._scenesStack;\n        let c = locScenesStack.length;\n\n        if (c === 0) {\n            return;\n        }\n\n        // current level or lower -> nothing\n        if (level > c)\n            return;\n\n        // pop stack until reaching desired level\n        while (c > level) {\n            let current = locScenesStack.pop();\n            c--;\n        }\n\n        let sceneName = locScenesStack[locScenesStack.length - 1];\n        logger.debug('goBackToSceneStackLevel sceneName = ' + sceneName);\n\n        /// 加载栈顶Scene\n        cc.director.loadScene(sceneName, function () {\n            logger.debug('goBack loadScene complete sceneName = ' + sceneName);\n\n            this._sceneLaunchHandle = true;\n            this.handleBack(parameter);\n        }.bind(this));\n    }\n\n    /**\n     * 获取指定scene名字的导航栈层级\n     * @param {string} sceneName -场景名字\n     */\n    sceneStackLevel(sceneName){\n        logger.debug('sceneStackLevel sceneName = ' + sceneName);\n\n        let locScenesStack = this._scenesStack;\n\n        let i = locScenesStack.length-1;\n        let exist = false;\n        for(; i>=0; --i){\n            if(locScenesStack[i] === sceneName){\n                exist = true;\n                break;\n            }\n        }\n\n        logger.debug('sceneStackLevel i = ' + i);\n\n        if(exist){\n            return i+1;\n        }\n\n        return -1;\n    }\n    /*-------------------------私有方法end-------------------------*/\n}\n\nmodule.exports = new Navigator();\n"]}